# -*- coding: utf-8 -*-
"""Assignment1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sX85sBqpwvazJraSVP5teLLKghXFhYEb
"""
import os
import numpy as np
import pandas as pd
from scipy.optimize import minimize
import matplotlib.pyplot as plt

# Assuming the model Z(u,w) = Z0(w)[1 - exp{-Lu/Z0(w)}]
def run_production_func(Z,L, u):
    return Z*(1-np.exp(-L*u/Z))

def data_cleanup(df):

    # Using the 1st innings data alone in the above data set, hence dropping the 2nd innings data
    df.drop(df.index[(df["Innings"]>1)],axis=0,inplace=True) #DataFrame without the removed index or column labels or None if inplace=True
    df.reset_index(drop=True, inplace=True) #reindexing the data after dropping rows

    # Dropping all rows where Error.In.Data value = 1
    for index, row in df.iterrows():
        if row['Error.In.Data']==1:
            df.drop(df.index[index], axis=0, inplace=True)

    df=df[df['Wickets.in.Hand']>0]
    df=df[df['Wickets.in.Hand']<11]
    df.reset_index(drop=True, inplace=True)

    df = df[['Match', 'Innings', 'Innings.Total.Runs', 'Total.Runs', 'Runs.Remaining', 'Over', 'Total.Overs', 'Wickets.in.Hand', 'Runs']]
    df['Overs_left'] = df['Total.Overs'] - df['Over']
    df['Total.Runs'] = df.groupby('Match', as_index=False)['Runs'].cumsum() # Cleaning up Runs.Remaining column
    df['Runs_to_score'] = df['Innings.Total.Runs'] - df['Total.Runs']
    df = df[['Match', 'Innings', 'Wickets.in.Hand', 'Runs_to_score', 'Overs_left']]

    return df

def loss_sqr_error(param, args):

    sqr_loss = []
    L = param[10] # last item in param list is the value of L
    innings = args[0]
    overs_left = args[1]
    runs_left = args[2]
    wickets_left = args[3]

    loss = 0 # will return updated loss

    for i in range(len(wickets_left)):
        #Z is Z0(w) i.e. value of Z0 for w number of wickets remaining
        z = param[wickets_left[i]-1]
        u = overs_left[i]
        runs_predicted = run_production_func(z, L, u)
        loss_sqr = (runs_predicted - runs_left[i])**2
        loss += loss_sqr

    return loss

def optimizer(method_name, innings, Remaining_overs, Runs_Remaining_cleaned, Wickets_in_Hand):

    #Using Method BFGS
    params_initial = [20, 45.0, 75.0, 100.0, 125.0,150.0, 175.0, 200.0, 225.0, 250.0, 10]
    params = minimize(loss_sqr_error, params_initial, args=[innings, Remaining_overs, Runs_Remaining_cleaned, Wickets_in_Hand], method=method_name)
    opt_params1, loss_sqr_error1 = params['x'], params['fun']
    return params['x'], params['fun']

def generate_plot(opt_params):

    # Plot the resource vs overs used graphs for 10 parameters
    plt.figure(figsize=(10, 7))  # Fig Size
    plt.xlabel('Overs Left(u)')
    plt.ylabel('Resources Remaining(%)')
    plt.xlim((0, 0))
    plt.ylim((0, 0))
    plt.xticks([0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50])
    plt.yticks([0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100])

    max_resource = run_production_func(opt_params[9], opt_params[10], 50)
    overs = np.arange(0, 51, 1)
    line = []

    #Plot Overs Left vs Resources Remaining
    for i in range(10):
        fraction = run_production_func(opt_params[i], opt_params[10], overs)/max_resource #P(u, w) = Z(u, w)/Z(N. 10)
        y = 100 * fraction
        plt.plot(overs, y, label='Z['+str(i+1)+']')
        plt.legend()

    plt.show()
    print("Plot Generated")

def main():
    data_path = "../data/"
    file_name = "04_cricket_1999to2011.csv"
    dataset = pd.read_csv(os.path.join(data_path, file_name))
    df = dataset.copy()
    df = data_cleanup(df)

    Remaining_overs = df['Overs_left'].values
    Wickets_in_Hand = df['Wickets.in.Hand'].values
    Runs_Remaining_cleaned = df['Runs_to_score'].values
    innings = df['Innings'].values

    print("--------Starting optimization of parameters--------")
    opt_params, loss_sqr_error = optimizer('L-BFGS-B', innings, Remaining_overs, Runs_Remaining_cleaned, Wickets_in_Hand)
    #Normalized square loss
    normalized_loss_sqr_error = loss_sqr_error/len(df)
    print("Finished!")

    print('Total Squared Err Loss = ', loss_sqr_error)
    print('Total Squared Err Loss Normalized = ', normalized_loss_sqr_error)
    print('L = ' + str(opt_params[10]))
    for i in range(10):
        print('Z' + str(i+1) + ' = ' + str(opt_params[i]))

    generate_plot(opt_params)

if __name__ == "__main__":
    main()
